[
    {
        "id": "6020ea8d49b51808",
        "type": "tab",
        "label": "Flow 1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "flow1",
        "type": "tab",
        "label": "EcoWatt Cloud",
        "disabled": false,
        "info": ""
    },
    {
        "id": "f557946168782514",
        "type": "http in",
        "z": "6020ea8d49b51808",
        "name": "",
        "url": "/api/v1/upload",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 520,
        "wires": [
            [
                "98aa2bc0cc14bd96"
            ]
        ]
    },
    {
        "id": "98aa2bc0cc14bd96",
        "type": "json",
        "z": "6020ea8d49b51808",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 370,
        "y": 520,
        "wires": [
            [
                "02d5167ba2f1685a",
                "027a10f451887250"
            ]
        ]
    },
    {
        "id": "02d5167ba2f1685a",
        "type": "function",
        "z": "6020ea8d49b51808",
        "name": "function 3",
        "func": "// --- 1. Parse & validate ---\nlet body = msg.payload;\n\nif (typeof body === \"string\") {\n    try {\n        body = JSON.parse(body);\n    } catch (err) {\n        msg.statusCode = 400;\n        msg.payload = { error: \"Invalid JSON\" };\n        return msg;\n    }\n}\n\nif (!body.device_id || !body.timestamp || !body.payload) {\n    msg.statusCode = 400;\n    msg.payload = { error: \"device_id, timestamp, and payload are required\" };\n    return msg;\n}\n\nconst pay = body.payload;\nconst compression = (pay.compression || \"none\").toLowerCase();\nconst base = pay.base || 0;\nconst input = pay.samples || [];\n\n// --- 2. Decompression for verification ---\nfunction fromDelta(base, deltas){\n  let out = [];\n  let prev = base;\n  for (const d of deltas){ prev += d; out.push(prev); }\n  return out;\n}\n\nfunction fromRLE(pairs){\n  let out = [];\n  for (const [val, count] of pairs){\n    for (let i=0; i<count; i++) out.push(val);\n  }\n  return out;\n}\n\nlet samplesDecompressed;\nif (compression === \"delta\") samplesDecompressed = fromDelta(base, input);\nelse if (compression === \"rle\") samplesDecompressed = fromRLE(input);\nelse samplesDecompressed = input;\n\n// --- 3. Benchmark metrics ---\nconst compBytes = Buffer.byteLength(JSON.stringify(pay), \"utf8\");\nconst bitDepth = pay.sample_bits || 16; // assume 16-bit raw samples\nconst origBytes = (samplesDecompressed.length * bitDepth) / 8;\nconst ratio = compBytes > 0 ? (origBytes / compBytes) : null;\n\n// --- 4. Save to Node-RED flow context (simple history buffer) ---\nlet history = flow.get(\"history\") || [];\nhistory.push({\n  device_id: body.device_id,\n  timestamp: body.timestamp,\n  compression,\n  original_bytes: origBytes,\n  compressed_bytes: compBytes,\n  compression_ratio: ratio,\n  samples_count: samplesDecompressed.length,\n  agg: pay.agg || null\n});\nif (history.length > 200) history = history.slice(-200);\nflow.set(\"history\", history);\n\n// --- 5. Reply with ACK ---\nmsg.payload = {\n  status: \"OK\",\n  next_upload_after_s: pay.upload_window_s || 15,\n  commands: [], // placeholder for Milestone 4\n  metrics: {\n    samples_count: samplesDecompressed.length,\n    original_bytes: origBytes,\n    compressed_bytes: compBytes,\n    compression_ratio: ratio\n  }\n};\n\nreturn msg;\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 520,
        "wires": [
            [
                "cfe19fd96414c1b5"
            ]
        ]
    },
    {
        "id": "cfe19fd96414c1b5",
        "type": "http response",
        "z": "6020ea8d49b51808",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 730,
        "y": 520,
        "wires": []
    },
    {
        "id": "027a10f451887250",
        "type": "debug",
        "z": "6020ea8d49b51808",
        "name": "debug 1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 660,
        "wires": []
    },
    {
        "id": "f969ed52d346e60e",
        "type": "http in",
        "z": "6020ea8d49b51808",
        "name": "",
        "url": "/api/v1/history/:device_id",
        "method": "get",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 200,
        "y": 840,
        "wires": [
            [
                "875cedfa6d5853b4"
            ]
        ]
    },
    {
        "id": "875cedfa6d5853b4",
        "type": "function",
        "z": "6020ea8d49b51808",
        "name": "function 1",
        "func": "// Extract device_id from URL\nlet deviceId = msg.req.params.device_id;\n\n// Retrieve stored history\nlet history = flow.get(\"history\") || [];\n\n// Filter records for this device\nlet filtered = history.filter(h => h.device_id === deviceId);\n\n// Always return consistent JSON\nmsg.payload = {\n    device_id: deviceId,\n    total_uploads: filtered.length,\n    metrics: {\n        total_samples: filtered.reduce((sum, h) => sum + (h.samples_count || 0), 0),\n        avg_compression_ratio: filtered.length > 0 \n            ? (filtered.reduce((sum, h) => sum + (h.compression_ratio || 0), 0) / filtered.length)\n            : null\n    },\n    uploads: filtered\n};\n\nmsg.statusCode = 200;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 840,
        "wires": [
            [
                "96c4eeec3d7d4cb3"
            ]
        ]
    },
    {
        "id": "96c4eeec3d7d4cb3",
        "type": "http response",
        "z": "6020ea8d49b51808",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 840,
        "wires": []
    },
    {
        "id": "http_in_upload",
        "type": "http in",
        "z": "flow1",
        "name": "POST /api/v1/upload",
        "url": "/api/v1/upload",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 120,
        "wires": [
            [
                "json_parse"
            ]
        ]
    },
    {
        "id": "json_parse",
        "type": "json",
        "z": "flow1",
        "name": "Parse JSON",
        "property": "payload",
        "action": "obj",
        "pretty": false,
        "x": 360,
        "y": 120,
        "wires": [
            [
                "function_ack"
            ]
        ]
    },
    {
        "id": "function_ack",
        "type": "function",
        "z": "flow1",
        "name": "Save + Reply",
        "func": "const fs = require('fs');\nconst path = './data/uplink.log';\n\n// append payload to file\nfs.appendFileSync(path, JSON.stringify(msg.payload) + '\\n');\n\n// reply back\nmsg.payload = { status: 'OK', commands: [] };\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "x": 560,
        "y": 120,
        "wires": [
            [
                "http_response"
            ]
        ]
    },
    {
        "id": "http_response",
        "type": "http response",
        "z": "flow1",
        "name": "Send ACK",
        "statusCode": "",
        "headers": {},
        "x": 780,
        "y": 120,
        "wires": []
    }
]